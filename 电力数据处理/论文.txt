摘要：
	电力用户分类是实现电力资源优化配置中最重要的方法之一。国家和企业通过分析用户需求、用电行为、用电习惯等，针对不同类型的用户给出不同的激励措施来增加绿色清洁的电力资源在人们日常使用能源中所占的比重。在对用户聚类的分析中有对海量、高速数据进行实时处理的需求。因此我们基于Spark streaming、改进的clusStream算法和改进的k-means算法实现了分布式用户用电数据流聚类方法 DStreamEPK。在最后的实验评估中，我们首先在在UCI数据集上测试了DStreamEPK的聚类的有效性，结果显示我们提出的DStreamEPK相比传统的k-means算法聚类效果更好。与此同时，通过在用户真实用电数据集上测试，发现DStreamEPK能快速高效的对用户用电数据进行聚类。
introduction:
1. 研究背景和重要性
2. 引出该领域科研空白（What Is Unknown）
Birch算法是一种层次聚类算法，由T.Zhang等人在1996年提出。C.C.Aggarwal等人在2003年提出了经典数据流双层处理框架ClusStrean。T.Rakthanmanon等人在2007年提出了E-Stream聚类算法改进了clusStream算法对于高位数据聚类性能差的问题。I.Assent等人在2011年提出了Clustree算法可以对任意形状分布的数据点进行有效聚类。R.Marcel等人在2012年提出了StreamKM++算法。



3. 点题—指出本文的研究课题（Topic Of Research Paper）

然而目前结合数据流和分布式计算的研究成果还比较少，仍处于探索的初级阶段。本文首先介绍传统的流聚类算法和分布式流处理平台，并分析当前流聚类算法存在的问题。并基于原有的流聚类算法提出基于SparkStreaming的流聚类算法DStreamEPK。DStreamEPK使用典型的双层聚类方法，在线部分使用X*树维持数据流概要信息；离线部分使用canopy解决k-means算法的初始K值选择问题，并设计高效分布式并行k-means算法对电力数据进行离线聚类分析。
4. 概述文章的核心方法论和主要发现
5. 概述贡献


CC.Aggarwal等人在clusStream算法中首次提出了双层流聚类框架，该算法把数据流聚类的过程当做一个变化的过程，而不是将所有的数据用相同的粒度来进行计算和保存。该算法可以及时的响应用户的查询和聚类请求，另外还能以不同的粒度返回聚类的结果。
该算法首次提出将流聚类过程划分为离线和在线聚类两部分。微聚类阶段使用微簇来表示原始数据中的聚类信息，因为微簇具有可加性，因此对数据的更新是增量式的。在宏聚类阶段，离线算法对在线阶段生成的所有微簇进行聚类就能够得到最终的结果，算法引入了金字塔式倾斜的时间窗口来处理不同时间段内时间的重要程度。也就是说，越接近当前时间的数据越重要。在clusStream算法在时间维度上使用比较细的粒度来保存新的数据点，用比较粗的粒度来保存旧的数据点，最终保存的数据快照类似于倒金字塔形状，如图所示
CluStream算法沿用了BIRCH算法的聚类特征向量（CF，ClusterFeatureVector）来保存数据流的概要信息。最早出现在 BIRCH 算法中的 CF 是一个三元组特征
向量{n,LS,SS}：n 为数据点的数目，LS 为 n 个点的线性和，SS 为 n 个点的平方和。LS 和 SS 都为与原始数据点维数相同的向量。由于 CF 具有可加性，因此微簇的更新可以通过向量运算来得到。例如，当一个新的数据点要被加入的微簇中，通过向量的加运算就能更新微簇的概要信息：

CluStream 算法中，除了时间戳 T，微簇的 CF 也维护了几个其他的时间标签——LST 为时间戳的和，SST 为时间戳的平方和。CluStream 通过判断数据点与其最近的微簇的距离以及距离阈值来决定是创建新的微簇还是合并到已有的微簇中。为了保持微簇数量的相对稳定，当生成一个新的微簇时，要从现有的微簇集中选择两个微簇进行合并操作或是丢弃一个较旧的微簇。这样可以使算法能够保持微簇中始终是较新的数据，同时也减少了内存的占用。 虽然该算法具有不错的运行效率和较好的聚类精度，但是因为采用了欧式距离来评价相似度，因此该算法只能对球状分布的数据流有较好的聚类效果。对于具有其他分布类型的数据流，该算法无法进行有效的聚类，另外该算法也无法很好地处理离群点问题。
the state of the micro-clusters at a clock time of 8 simultaneously corresponds to order 0, order 1,order 3 snapshots.

R*树主要用于多维数据中执行相似性查找，SS树是基于R*树进行改进后的索引树。原始的R*树使用超立方体的形式来进行多维空间划分，这种划分方式会导致树形索引中的结点产生大量的重叠。然而SS树采用超球体的方式来划分空间，SS树除了子空间的中心点和半径需要保留之外，不需要其他额外数据，因此可以节省空间，并且提升查找的速度。

基于SS树的聚类算法执行流程：
将SS树结构进行初始化
对接受的数据进行预先聚类，生成若干微簇
当新的数据点X到了，根据X到各个micro-cluster中心的距离是否大于微簇的RMS deviation（均方根误差），大于则为q点新建立一个独立id的micro-cluster，否则 加入到距离最近的现有micro-cluster（利用特征向量组的可加性质）。

一旦有新micro-cluster建立，则需要删除一个原来的micro-cluster，理论上通常根据最近到达各个微簇的m个点所形成recent time stamp来确定删除那个微簇，在实际应用中根据微簇中的时间统计信息可以得到各个数据点到达时间的均值和标准差，由于默认微簇满足正态分布，所以提取m/(2*n)的时间信息relevance time和预设的阈值δ进行比较，如果最小的relevance time小于δ，则可以删除对应的micro-cluster。

如果所有的relevance time的值都比δ大，则需要合并两个距离最近的micro-cluser，同时将对应id形成一个idlist。

经验表明，具有时间戳的数据之间的重要性是不同的，最新的数据对用户的影响更大。也就是说，数据流信息具有时效性。当某一部分数据存在超过一定的时间，这部分数据很可能会是去价值。clusStream算法使用金字塔时间窗口来保存不同时间段的微簇。在我们的研究中我们使用更加简单的时间衰减技术来对微簇进行定期的更新和删除。时间衰减技术可以根据设定的函数使不同时间的数据显示出不同的重要性。在算法中设置一个进程，在固定的时间间隔会对所有的数据进行一次更新和删除，通过这种方式可以降低历史数据的影响：
时间加权函数如下：
在上面的公式中，a是衰减因子，其值的大小体现了历史数据在聚类中所起的作用，数值越大，说明历史数据对算法的影响越小。
对微簇的时间衰减函数计算如下：

当分布式集群的节点数目没有限制时，将传统聚类算法在 Spark Streaming中并行化后，随着计算节点的增加可以提高算法的性能。但是在机器不足且算法的运行效率无法满足应用的需求时，对算法本身的设计思想和执行逻辑进行优化也是一个很好的解决方法。

本文对流聚类算法的优化主要体现在 K-Means算法类簇初始中心点的选取和簇数目 k 值的设定以及k-means算法在Spark集群上的执行方法。 
首先，本文选取 Canopy 粗聚类算法来实现流聚类算法的内部优化。通过 Canopy算法的聚类结果来为 K-Means 提供初始的聚类中心点及 k 值，这样能够有效避免 K-Means 计算结果的随机性和减少运行时间，进而提升了 K-Means 对于大规模数据的处理性能。
其次，通过使用map,combine,reduce三个函数在spark集群上实现了高效的分布式并行k-means算法。

Canopy算法虽然不需要设定类簇的个数K值，但是其需要制定距离范围Db和Ds,其中Db指的是最大距离阈值，Ds指的是最小距离阈值。二者之间满足关系Db>Ds，通过距离阈值的设定可以影响到聚类结果中canopy子集的数目以及自己中的数据点。但是如果Db太大，会导致许多点同时属于多个Canopy，最终可能导致各个簇中心点之间的区别比较小，各个簇之间区别不明显。如果Ds太大则有可能会导致簇的数量过少，但如果Ds太小会导致簇的数量过多，大大增加聚类时间。因此一定要合理的设置Db与Ds的数值。

Canopy算法的步骤如下：
将数据集R读入内存，之后设定好距离阈值参数Db与Ds。
从R中随机选取一个数据点d,并计算d到所有canopy子集中心的距离。如果初始时没有任何canopy子集，就需要把数据点d当做新的canopy贾如canopy列表中，与此同时将d从R中移除。如果数据d到某个canopy的中心之间的距离小于等于Db那么就把d写入到这个canopy中,但是不从R中删除该数据。
如果数据点d与某个canopy的中心距离不大于Ds，就把d写入到该canopy中并将该节点从R中删除。
重复步骤2,3直到R成为空数据集。

Canopy 算法不需要手动去指定聚类的数目，它可以依据自身的迭代来主动聚簇成类，只需要设定聚类过程中的阈值  Db、Ds，其中 Db>Ds。故可以将Canopy 粗聚类算法与 K-Means 算法结合起来，用 Canopy 算法的输出作为K-Means 的输入。这样可以在一定程度上合理规避 K-Means中k选取的主观性和初始类簇中心点选取的随机性，从而通过减少 K-Means聚类算法中的迭代次数来提高效率并同时提高聚类的准确性。基于以上分析可以提出基于 Canopy 的 K-Means 优化算法的执行步骤如下：
步骤 1：将数据集 R 预处理后得到一个数据列表 R'后写入内存，选取合适的距离阈值：Db、Ds（Db>Ds）。
步骤 2：按照Canopy方法将R'中的所有数据划分为若干个Canopy。
步骤 3：使用步骤2中产生的Canopy个数作为K-means算法的K值。
步骤 4：执行K-means算法。

R树是一棵用来存储高维数据的平衡树，它很好的解决了高维空间中的搜索问题。R树将B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。

R树是B树在高维空间的扩展，是一棵平衡树。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。

